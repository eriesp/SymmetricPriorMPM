opt.cluster <- function(df_small){
# if you wanna perform it
# Elbow Method
fviz_nbclust(df_small, FUN = hcut, method = "wss")
# Silhoutte Method
sil <- fviz_nbclust(df_small, FUN = hcut, method = "silhouette")
max.sil <- max(sil$data[,2])
cat("Optimal number of clusters with Silhouette method:", which(sil$data[2,] == max.sil))
return(max.sil + 1)
}
# to get the cluster column
#!!!! PAY ATTENTION TO THE RIGHT NUMBER OF CLUSTERS!!!!
# usually it's 3 but then try with a different number (2 or 4) and see what happens
hier.clust <- function(df_small){
# !!!!!!!!! if you wanna change the num of clusters do it here
# numclust <- opt.cluster(df_small)
numclust <- 3
mydf<- scale(df_small)
# distance matrix
de <- dist(mydf, method = "euclidean")
# clustering with average method
hc_ea <- hclust(de, method = "average" )
# cluster column of the small dataset
cluster_col <- cutree(hc_ea, k = numclust)
table(cluster_col)
return(cluster_col)
}
# the big func which calls all the others
# input: name of the file of the image
# output: some statistics of the image (mean, variance, cov btw channels, quantiles, min, max)
get.img.values <- function(filename){
mystack <- stack(filename)
# creating the dataset
df_full <- as.data.frame(mystack, row.names=NULL,
optional=FALSE, xy=FALSE, na.rm=FALSE, long=FALSE)
df_full <- df_full[,-4]
colnames(df_full) = c("band1_R","band2_G","band3_B")
# cleaning the dataset
result <- select.rows(df_full, mystack)
df_small <- result$df_small
rows_to_keep <- result$rows_to_keep
# hiercical clustering
cluster_small <- hier.clust(df_small)
num_righe <- dim(df_full)[1]
Clusters <- rep(NA, num_righe)
Clusters[rows_to_keep] <- cluster_small
ValClusters <- setValues(mystack,Clusters)
# Plot of the clusters
#  x11()
par(mfrow = c(1,2))
plotRGB(mystack, col = rev(terrain.colors(10)), main = 'RGB plot')
plot(ValClusters$layer.4, main = 'Unsupervised classification')
# adding the cluster column to the dataframe
df_full <- as.data.frame(cbind(df_full, Clusters))
# ======================================
#         ADD HERE THE NUMBER
#         OF THE RIGHT CLUSTER
#   OF WHICH I TAKE THE STATISTICS
# =======================================
#modify this variable with the number of the right cluster
#my_clust <- 2
my_clust <- readline(prompt="Enter number of the cluster representing the street: ")
dev.off()
mean_of_my_clust <- aggregate(.~ Clusters, FUN = mean, data = df_full[ , c(1,2,3)] ) [my_clust, 2:4]
# var_of_my_clust <- aggregate(.~ Clusters, FUN = var, data = df_full[ , c(1,2,3)] ) [my_clust, 2:4 ]
# plotting the histograms of each channel
# very useless
par(mfrow = c(1,3))
hist(df_full$band1_R[which(df_full$Clusters == my_clust)], main = "Band R")
hist(df_full$band2_G[which(df_full$Clusters == my_clust)], main = "Band G")
hist(df_full$band3_B[which(df_full$Clusters == my_clust)], main = "Band B")
# covariance quantiles min max (kurtosis)
cov_matrix <- cov(df_full[which(df_full$Clusters == my_clust), ]) [-4,-4]
quantiles <- aggregate(.~ Clusters, FUN = quantile, probs = c(0.25, 0.5, 0.75),
data = df_full[ , c(1,2,3)] ) [my_clust, ]
quantiles <- rbind(quantiles$band1_R,quantiles$band2_G,quantiles$band3_B)
rownames(quantiles) <- c("band1_R","band2_G","band3_B")
min_my_clust <- aggregate(.~ Clusters, FUN = min, data = df_full[ , c(1,2,3)] ) [my_clust,2:4]
max_my_clust <- aggregate(.~ Clusters, FUN = max, data = df_full[ , c(1,2,3)] ) [my_clust,2:4]
lenght_my_clust <- aggregate(.~ Clusters, FUN = length, data = df_full[ , c(1,2,3)] ) [my_clust,2:4]
return(list(mean = mean_of_my_clust,
# variance = var_of_my_clust,
cov.matrix = cov_matrix,
quantiles = quantiles,
min = min_my_clust,
max = max_my_clust,
lenght = lenght_my_clust))
}
save(get.img.values, hier.clust,opt.cluster, select.rows, vi,
file = "~/UNI/APPLIED STATISTICS/PROJECT - Road pavement detection/funcs.RData")
# Using the R package fdakma
library(fdakma)
help(kma.data)
data(kma.data)
x <- kma.data$x   # abscissas
y0 <- kma.data$y0 # evaluations of original functions
y1 <- kma.data$y1 # evaluations of original functions' first derivatives
# Plot of original functions
matplot(t(x),t(y0), type='l', xlab='x', ylab='orig.func')
title ('Original functions')
# Plot of original functions
matplot(t(x),t(y0), type='l', xlab='x', ylab='orig.func')
set.seed(24021979)
n <- 50
# covariate values
x1 <- runif(n,0,10)
x2 <- (1:n)/5
x3 <- rnorm(n,5,5)
b0 <- 2
b1 <- 4
b2 <- -2
b3 <- 0
Y <- b0 + b1*x1 + b2*x2 + b3*x3 + runif(n,-5,5)
plot(x1,Y,pch=16)
plot(x2,Y,pch=16)
plot(x3,Y,pch=16)
result <- lm(Y ~ x1 + x2 + x3)
summary(result)
qqnorm(result$residuals)
shapiro.test(result$residuals)
# Overall model
# H0: beta1 = beta2 = beta3 = 0
# test statistic
T0_glob <- summary(result)$f[1]
T0_glob
# permutations
permutazione <- sample(n)
Y.perm.glob <- Y[permutazione]
permutazione
# in this case permuting the responses or the residuals is the same
res.H0glob <- Y - mean(Y)
Y.perm.glob
mean(Y) + res.H0glob[permutazione]
layout(matrix(1:6,nrow=3,byrow=FALSE))
plot(x1,Y,main='Y vs x1 (original data)',pch=16)
plot(x2,Y,main='Y vs x2 (original data)',pch=16)
plot(x3,Y,main='Y vs x3 (original data)',pch=16)
plot(x1,Y.perm.glob,main='Y vs x1 (permuted data)',pch=16)
plot(x2,Y.perm.glob,main='Y vs x2 (permuted data)',pch=16)
plot(x3,Y.perm.glob,main='Y vs x3 (permuted data)',pch=16)
summary(result)$coefficients
T0_x1 <- abs(summary(result)$coefficients[2,3])
T0_x1
regr.H01 <- lm(Y ~ x2 + x3)
residui.H01 <- regr.H01$residuals
residui.H01.perm <- residui.H01[permutazione]
# permuted y:
Y.perm.H01 <- regr.H01$fitted + residui.H01.perm
layout(matrix(1:6,nrow=3,byrow=FALSE))
plot(x1,Y,main='Y vs x1 (original data)',pch=16)
plot(x2,Y,main='Y vs x2 (original data)',pch=16)
plot(x3,Y,main='Y vs x3 (original data)',pch=16)
plot(x1,Y.perm.H01,main='Y vs x1 (permuted data)',pch=16)
plot(x2,Y.perm.H01,main='Y vs x2 (permuted data)',pch=16)
plot(x3,Y.perm.H01,main='Y vs x3 (permuted data)',pch=16)
summary(result)$coefficients
T0_x2 <- abs(summary(result)$coefficients[3,3])
T0_x2
# permutations
# residuals of the reduced model
# reduced model:
# Y = beta0 + beta1*x1 + beta3*x3
regr.H02 <- lm(Y ~ x1 + x3)
residui.H02 <- regr.H02$residuals
residui.H02.perm <- residui.H02[permutazione]
# permuted y:
Y.perm.H02 <- regr.H02$fitted + residui.H02.perm
layout(matrix(1:6,nrow=3,byrow=FALSE))
plot(x1,Y,main='Y vs x1 (original data)',pch=16)
plot(x2,Y,main='Y vs x2 (original data)',pch=16)
plot(x3,Y,main='Y vs x3 (original data)',pch=16)
plot(x1,Y.perm.H02,main='Y vs x1 (permuted data)',pch=16)
plot(x2,Y.perm.H02,main='Y vs x2 (permuted data)',pch=16)
plot(x3,Y.perm.H02,main='Y vs x3 (permuted data)',pch=16)
summary(result)$coefficients
T0_x3 <- abs(summary(result)$coefficients[4,3])
T0_x3
# permutations
# residuals of the reduced model
# reduced model:
# Y = beta0 + beta1*x1 + beta2*x2
regr.H03 <- lm(Y ~ x1 + x2)
residui.H03 <- regr.H03$residuals
residui.H03.perm <- residui.H03[permutazione]
# permuted y:
Y.perm.H03 <- regr.H03$fitted + residui.H03.perm
layout(matrix(1:6,nrow=3,byrow=FALSE))
plot(x1,Y,main='Y vs x1 (original data)',pch=16)
plot(x2,Y,main='Y vs x2 (original data)',pch=16)
plot(x3,Y,main='Y vs x3 (original data)',pch=16)
plot(x1,Y.perm.H03,main='Y vs x1 (permuted data)',pch=16)
plot(x2,Y.perm.H03,main='Y vs x2 (permuted data)',pch=16)
plot(x3,Y.perm.H03,main='Y vs x3 (permuted data)',pch=16)
B <- 1000
T_H0glob <- T_H01 <- T_H02 <- T_H03 <- numeric(B)
for(perm in 1:B){
permutazione <- sample(n)
Y.perm.glob <- Y[permutazione]
T_H0glob[perm] <- summary(lm(Y.perm.glob ~ x1 + x2 + x3))$f[1]
residui.H01.perm <- residui.H01[permutazione]
Y.perm.H01 <- regr.H01$fitted + residui.H01.perm
T_H01[perm] <- abs(summary(lm(Y.perm.H01 ~ x1 + x2 + x3))$coefficients[2,3])
residui.H02.perm <- residui.H02[permutazione]
Y.perm.H02 <- regr.H02$fitted + residui.H02.perm
T_H02[perm] <- abs(summary(lm(Y.perm.H02 ~ x1 + x2 + x3))$coefficients[3,3])
residui.H03.perm <- residui.H03[permutazione]
Y.perm.H03 <- regr.H03$fitted + residui.H03.perm
T_H03[perm] <- abs(summary(lm(Y.perm.H03 ~ x1 + x2 + x3))$coefficients[4,3])
}
sum(T_H0glob>=T0_glob)/B
sum(T_H01>=T0_x1)/B
sum(T_H02>=T0_x2)/B
sum(T_H03>=T0_x3)/B
summary(result)
q()
update.packages(ask = FALSE, checkBuilt = TRUE)
library(rgl)
knitr::opts_chunk$set(echo = TRUE)
knitr::knit_hooks$set(webgl = hook_webgl)
B = 100000
seed = 26111992
library(rgl)
open3d()
plot3d(t1-t2, size=3, col='orange', aspect = F)
t1 <- read.table('meteo_data/barcellona.txt', header=T)
t2 <- read.table('meteo_data/milano.txt', header=T)
# two samples (not independent) considered as paired
library(rgl)
open3d()
plot3d(t1-t2, size=3, col='orange', aspect = F)
points3d(0,0,0, size=6)
p  <- dim(t1)[2]
n1 <- dim(t1)[1]
n2 <- dim(t2)[1]
n <- n1+n2
t1.mean <- colMeans(t1)
t2.mean <- colMeans(t2)
t1.cov  <-  cov(t1)
t2.cov  <-  cov(t2)
Sp      <- ((n1-1)*t1.cov + (n2-1)*t2.cov)/(n1+n2-2)
Spinv   <- solve(Sp)
delta.0 <- c(0,0,0)
diff <- t1-t2
diff.mean <- colMeans(diff)
diff.cov <- cov(diff)
diff.invcov <- solve(diff.cov)
T20 <- as.numeric(n1 * (diff.mean-delta.0)  %*% (diff.mean-delta.0))
T2 <- numeric(B)
set.seed(seed)
for(perm in 1:B)
{
# Random permutation
# obs: exchanging data within couples means changing the sign of the difference
signs.perm <- rbinom(n1, 1, 0.5)*2 - 1
diff_perm <- diff * matrix(signs.perm,nrow=n1,ncol=p,byrow=FALSE)
diff.mean_perm <- colMeans(diff_perm)
diff.cov_perm <- cov(diff_perm)
diff.invcov_perm <- solve(diff.cov_perm)
T2[perm] <- as.numeric(n1 * (diff.mean_perm-delta.0) %*% (diff.mean_perm-delta.0))
}
T20 <- as.numeric((diff.mean-delta.0)  %*% (diff.mean-delta.0))
# moltiplicato per n1 perché alrimenti biased (maybe?)
T2 <- numeric(B)
set.seed(seed)
for(perm in 1:B)
{
# Random permutation
# obs: exchanging data within couples means changing the sign of the difference
signs.perm <- rbinom(n1, 1, 0.5)*2 - 1
diff_perm <- diff * matrix(signs.perm,nrow=n1,ncol=p,byrow=FALSE)
diff.mean_perm <- colMeans(diff_perm)
diff.cov_perm <- cov(diff_perm)
diff.invcov_perm <- solve(diff.cov_perm)
T2[perm] <- as.numeric((diff.mean_perm-delta.0) %*% (diff.mean_perm-delta.0))
}
# plotting the permutational distribution under H0
hist(T2,xlim=range(c(T2,T20)),breaks=100)
abline(v=T20,col=3,lwd=4)
plot(ecdf(T2))
abline(v=T20,col=3,lwd=4)
# p-value
p_val <- sum(T2>=T20)/B
p_val
# uso la mahal.. distance per scalare in realtà le mie coordinateS
T20 <- as.numeric(n1 * (diff.mean-delta.0) %*% solve(diag(diag(diff.cov))) %*% (diff.mean-delta.0))
# Estimating the permutational distribution under H0
T2 <- numeric(B)
set.seed(seed)
for(perm in 1:B)
{
# Random permutation
# obs: exchanging data within couples means changing the sign of the difference
signs.perm <- rbinom(n1, 1, 0.5)*2 - 1
diff_perm <- diff * matrix(signs.perm,nrow=n1,ncol=p,byrow=FALSE)
diff.mean_perm <- colMeans(diff_perm)
diff.cov_perm <- cov(diff_perm)
diff.invcov_perm <- solve(diff.cov_perm)
T2[perm] <- as.numeric(n1 * (diff.mean_perm-delta.0) %*% solve(diag(diag(diff.cov_perm))) %*% (diff.mean_perm-delta.0))
}
# plotting the permutational distribution under H0
hist(T2,xlim=range(c(T2,T20)),breaks=100)
abline(v=T20,col=3,lwd=4)
plot(ecdf(T2))
abline(v=T20,col=3,lwd=4)
# p-value
p_val <- sum(T2>=T20)/B
p_val
T20 <- as.numeric(n1 * (diff.mean-delta.0) %*% diff.invcov %*% (diff.mean-delta.0))
# Estimating the permutational distribution under H0
set.seed(seed)
T2 <- numeric(B)
for(perm in 1:B)
{
# Random permutation
# obs: exchanging data within couples means changing the sign of the difference
signs.perm <- rbinom(n1, 1, 0.5)*2 - 1
diff_perm <- diff * matrix(signs.perm,nrow=n1,ncol=p,byrow=FALSE)
diff.mean_perm <- colMeans(diff_perm)
diff.cov_perm <- cov(diff_perm)
diff.invcov_perm <- solve(diff.cov_perm)
#T2[perm] <- as.numeric(n1 * (diff.mean_perm-delta.0) %*% (diff.mean_perm-delta.0))
#T2[perm] <- as.numeric(n1 * (diff.mean_perm-delta.0) %*% solve(diag(diag(diff.cov_perm))) %*% (diff.mean_perm-delta.0))
T2[perm] <- as.numeric(n1 * (diff.mean_perm-delta.0) %*% diff.invcov_perm %*% (diff.mean_perm-delta.0))
}
# plotting the permutational distribution under H0
hist(T2,xlim=range(c(T2,T20)),breaks=100)
abline(v=T20,col=3,lwd=4)
plot(ecdf(T2))
abline(v=T20,col=3,lwd=4)
# p-value
p_val <- sum(T2>=T20)/B
p_val
T20
# plotting the permutational distribution under H0
hist(T2,xlim=range(c(T2,T20)),breaks=100)
abline(v=T20,col=3,lwd=4)
plot(ecdf(T2))
abline(v=T20,col=3,lwd=4)
# p-value
p_val <- sum(T2>=T20)/B
p_val
library(rgl)
knitr::opts_chunk$set(echo = TRUE)
knitr::knit_hooks$set(webgl = hook_webgl)
seed=2781991
B=1000
seed=2781991
B=1000
data=stabledist::rstable(1000,1.5,0)
library(rgl)
knitr::opts_chunk$set(echo = TRUE)
knitr::knit_hooks$set(webgl = hook_webgl)
data=stabledist::rstable(1000,1.5,0)
install.packages("stabledist")
data=stabledist::rstable(1000,1.5,0)
hist(data)
median(data)
set.seed(seed)
data=stabledist::rstable(1000,1.5,0)
hist(data)
median(data)
median(data)
uni_t_perm=function(data,mu0,B=1000){
data_trans=data-mu0
T0=abs(mean(data_trans))
T_perm=numeric(B)
n=length(data)
for(perm in 1:B){
refl <- rbinom(n, 1, 0.5)*2 - 1
T_perm[perm]=abs(median(data_trans*refl))
}
return(sum(T_perm>=T0)/B)
}
# definizione della grid
grid=seq(-3,3,by=0.001)
length(grid)
library(pbapply)
install.packages("pbapply")
library(pbapply)
library(parallel)
detectCores()
cl=makeCluster(detectCores())
clusterExport(cl,varlist=list("data","uni_t_perm"))
perm_wrapper=function(grid_point){uni_t_perm(data,grid_point,B=2000)}
pval_function=pbsapply(grid,perm_wrapper,cl=cl)
plot(grid,pval_function,type='l')
range(grid[pval_function>0.05])
library(rgl)
knitr::opts_chunk$set(echo = TRUE)
knitr::knit_hooks$set(webgl = hook_webgl)
B = 1000
seed = 26111992
head(chickwts)
attach(chickwts)
summary(chickwts)
g <- nlevels(feed)
n <- dim(chickwts)[1]
plot(feed, weight, xlab='treat',col=rainbow(g),main='Original Data')
fit <- aov(weight ~ feed)
summary(fit)
# brief recap
T0 <- summary(fit)[[1]][1,4]
T0
summary(fit)
# I take the F statistic
T0 <- summary(fit)[[1]][1,4]
T0
T_stat <- numeric(B)
n <- dim(chickwts)[1]
for(perm in 1:B){
# Permutation:
permutation <- sample(1:n)
weight_perm <- weight[permutation]
fit_perm <- aov(weight_perm ~ feed)
# Test statistic:
T_stat[perm] <- summary(fit_perm)[[1]][1,4]
}
hist(T_stat,xlim=range(c(T_stat,T0)),breaks=30)
abline(v=T0,col=3,lwd=2)
plot(ecdf(T_stat),xlim=c(-1,20))
abline(v=T0,col=3,lwd=4)
# p-value
p_val <- sum(T_stat>=T0)/B
p_val
library(lmPerm)
install.packages("lmPerm")
library(lmPerm)
lmp=aovp(weight_perm ~ feed,perm="Prob",Cp=0.1)#cp is supposed to stop iterations when standard error is at that level...
summary(lmp)
lmp=aovp(weight_perm ~ feed,perm="Prob",Cp=1e-6)
summary(lmp)
lmp=aovp(weight_perm ~ feed,perm="Prob",Cp=1e-6)
summary(lmp)
lmp=aovp(weight_perm ~ feed,perm="Prob",Cp=1e-6)
summary(lmp)
lmp=aovp(weight_perm ~ feed,perm="Prob",Cp=1e-6)
summary(lmp)
data(iris)
attach(iris)
head(iris)
species.name <- factor(Species, labels=c('setosa','versicolor','virginica'))
iris4        <- iris[,1:4]
plot(iris4,col=species.name)
i1 <- which(species.name=='setosa')
i2 <- which(species.name=='versicolor')
i3 <- which(species.name=='virginica')
n1 <- length(i1)
n2 <- length(i2)
n3 <- length(i3)
n  <- n1+n2+n3
g  <- length(levels(species.name))
p  <- 4
fit <- manova(as.matrix(iris4) ~ species.name)
summary.manova(fit,test="Wilks")
T0 <- -summary.manova(fit,test="Wilks")$stats[1,2]
T0
set.seed(seed)
T_stat <- numeric(B)
for(perm in 1:B){
# choose random permutation
permutation <- sample(1:n)
species.name.perm <- species.name[permutation]
fit.perm <- manova(as.matrix(iris4) ~ species.name.perm)
T_stat[perm] <- -summary.manova(fit.perm,test="Wilks")$stats[1,2]
}
hist(T_stat,xlim=range(c(T_stat,T0)),breaks=30)
abline(v=T0,col=3,lwd=2)
plot(ecdf(T_stat),xlim=c(-2,1))
abline(v=T0,col=3,lwd=4)
# p-value
p_val <- sum(T_stat>=T0)/B
p_val
install.packages("cmdstanr", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
cmdstanr::install_cmdstan()
check_cmdstan_toolchain(fix = TRUE)
library(cmdstanr)
check_cmdstan_toolchain(fix = TRUE)
cmdstanr::install_cmdstan()
install.packages("cmdstanr", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
cmdstanr::install_cmdstan()
library(rjags)
library(coda)
# for plots
library(ggplot2)
library(tidyr)
library(dplyr)
library(purrr)
library(ggsci)
require(gplots)
require(ggpubr)
# MNP sui nostri dati
setwd("~/UNI/BAYESIAN STATISTICS/PTOJECT")
library(MNP)
X <- read.csv(file = "Datasets/Data_50/X.csv", header = TRUE, sep = ",")
X = X[1:1000,]
n = dim(X)[1]
p = 10
Y <- factor(X[seq(from = 1, to = n, by = p ),dim(X)[2]])
agent_cov = X[seq(from = 1, to = n, by = p ),12:14]
head(Y)
head(agent_cov)
prod_cov <- data.frame(matrix(ncol = p, nrow = n/10))
colnames(prod_cov) = c("PPk_Stk", "PBB_Stk", "PFl_Stk", "PHse_Stk", "PGen_Stk", "PImp_Stk",
"PSS_Tub", "PPk_Tub", "PFl_Tub", "PHse_Tub")
for (i in 1:(n/10)){
prod_cov[i,] = t(X[i:(i+9),42])
}
head(prod_cov)
agent_prod = cbind(agent_cov,prod_cov)
head(agent_prod)
accuracies
setwd("~/UNI/BAYESIAN STATISTICS/Project-GIT/SymmetricPriorMPM")
